RELEASE NOTES 0.10.4 (202?-??-??)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
1. Tools: Unit tests

To write unit tests for Rell code, use test modules. A test module is defined using the @test annotation:

    @test module;

    function test_foo() {
        require( 2 + 2 == 4 );
    }

    function test_bar() {
        require( 2 + 2 == 5 );
    }

All functions in a test module that start with "test_" (and a function called exactly "test") are test functions and
will be executed when the test module is run.

To run a test module, use the command-line interpreter:

rell.sh -d my_src_directory my_test_module

Each test function will be executed independently of others, and a summary will be printed in the end:

    ------------------------------------------------------------------------
    TEST RESULTS:

    my_test_module:test_foo OK
    my_test_module:test_bar FAILED

    SUMMARY: 1 FAILED 1 PASSED 2 TOTAL


    ***** FAILED *****

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Tools: Executing transactions and blocks in unit tests

Blocks and transactions created via functions rell.gtx.block() and rell.gtx.tx() can be executed in unit tests
in order to invoke operations and modify data.

Example. Production module, file data.rell:

    module;

    entity user {
        name;
    }

    operation add_user(name) {
        create user(name);
    }

Test module, file data_test.rell:

    @test module;
    import data;

    function test_add_user() {
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        val tx = rell.gtx.tx(data.add_user('Bob'));
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        tx.run();
        require( data.user@*{}(.name) == ['Bob'], 'expected_user_bob' );
    }

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
3. Library: Support for text and byte_array functions in @-expressions

Following functions are now supported in @-expressions (they are translated to their SQL equivalents):

    byte_array.empty()
    byte_array.sub()
    byte_array.to_base64()
    byte_array.to_hex()

    text.char_at()
    text.contains()
    text.empty()
    text.ends_with()
    text.index_of()
    text.replace()
    text.starts_with()
    text.sub()

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Language: Operator [] for text and byte_array types in @-expressions

Subscript operator used to work only in interpreted expressions, now it works in SQL expressions as well.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
5. Library: Function text.like()

New function for simple pattern matching which works same way in interpreted expressions and in @-expressions:

    text.like(pattern): boolean

is equivalent to the SQL LIKE clause:

    <text> LIKE <pattern>

Special character "_" matches any single character and "%" matches any string of zero or more characters.

    print(name.like('% von %'))
    user @* { .name.like('% von %') }

To match characters "_" and "%", escape them with "\" (note that "\\_" in a string literal produces "\_" at run-time,
since "\" is also an escape character in string literals):

    title.like('string\\_with\\_underscores')

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
6. Language: Inference of collection types from return types, variables, attributes, parameters, etc.

It is no more necessary to specify the type of an empty collection when assigning it to a known variable or returning
from a function with a known return type:

    function f(q: integer): list<map<integer,text>> {
        if (q < 0) return [];   // In the past one had to write full type specification: list<map<integer,text>>().
        // ...
    }

Works for lists, sets and maps, for both literals (e. g. [], [:]) and constructors (list(), set(), map()):

    var x: set<text>;
    x = set();

    var m: map<integer, text>;
    m = [:];

"[:]" is a new empty map literal notation, equivalent to expression "map()":

    val m: map<integer, text> = [:];

Some places where collection type inference helps to shorten the code:

- function arguments:                   f([]);
- function parameter default values:    function f(x: list<integer> = []){}
- struct constructor invocation:        my_struct(x = []);
- struct attribute assignment:          struct_object.x = [];
- list/map element assignment:          map_of_lists[x] = [];

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
7. Language: Continue statement

Rell now has the continue statement, like many other languages. It can be used in for and while loops.

for (x in get_list_of_values()) {
    if (x < 0) continue;
    // Do something.
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
8. Language: Offset clause in at-expression

In addition to a limit, one can now also specify an offset in an at-expression in order to select a portion of a
result set:

    user @* {} offset X limit Y

The offset is zero-based, so if offset 0 is specified, all records will be returned, while offset 1 will skip the first
record and so on.

Both limit and offset clauses are optional and can be used together in an arbitrary order.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
9. Language: At-expression for collections

At-expressions can be used to filter and transform collections:

    val l = [1, 2, 3, 4, 5, 6, 7];
    val x = l @* { $ > 4 };
    val y = l @* {} ( $ * $ );

Special symbol "$" is used to access the current item in where- and what-parts. A custom alias can be specified instead:

    val z = (a : l) @* { a > 4 };

Transforming a map:

    val m = ['France':33, 'Italy':39, 'Germany':49];
    val keys = m @* {} ( $.k );
    val values = m @* {} ( $.v );

At-expressions can be chained:

    val q = l
        @* { $ >= 2 }
        @* {} ( $ * $ )
        @* { $ <= 25 }
        ;

Operations are performed in memory, not in database. If applying "at" to a list of entities, each entity will be
selected from the database individually in order to access its attributes (may be slow):

    val all_users = user @* {};                     // Select all users with one SQL query.
    val good_users = all_users @* { $.is_good };    // Slow: will execute SQL query for every user to read its "is_good".

Details:

- All kinds of at-operators are supported: "@", "@?", "@*", "@+".
- Source collection can be a list, a set or a map; the result is always a list (or a single value).
- Where- and what-expressions are not restricted to SQL-compatible ones (e. g. user-defined function calls are allowed).
- Limit and offset clauses are supported.
- Annotations @sort, @sort_desc and @omit are supported.
- Grouping and aggregation is supported (via annotations @group, @sum, @min, @max).

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
10. Language: Key and index attribute syntax improvements

Now one can specify mutability and default value for particular attributes within a key or index clause:

    entity address {
        index mutable city: text = 'London', mutable street: text = 'Unknown';
    }

In previous versions that code would like like this:

    entity address {
        mutable city: text = 'London';
        mutable street: text = 'Unknown';
        index city, street;
    }

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
11. Language: Types struct<entity> and struct<object>

A new type allows to have a struct which has same attributes as an entity or an object:

    entity user {
        name;
        address: text;
    }

    operation add_user(data: struct<user>) {
        //...
    }

An instance of a struct<T> can be created same way as for a regular struct:

    val s = struct<user>(name = 'Bob', address = '33 Main St.');

It's also possible to obtain a struct-copy of an entity/object using the 'to_struct()' function:

    val u = user @ { .name == 'Bob' };
    val s = u.to_struct();              // returns struct<user>

Alternatively, 'to_struct()' can be used in an at-expression (in the what-part):

    val s = user @ { .name == 'Bob' } ( user.to_struct() );

One can pass a struct<entity> to a create expression instead of specifying individual attributes of the entity:

    create user(s);       // s is struct<user>

Details:

- Attributes of struct<T> are not mutable regardless of the mutability of the attributes of the underlying type.
- Attributes of struct<T> have same default values as the attributes of T.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
12. Language: Type struct<operation>

A new type struct<operation> defines a struct which has same attributes as the operation's parameters:

    operation add_user(name: text, rating: integer) {
        //...
    }

    query can_add_user(user: struct<add_user>) {
        if (user.name == '') return false;
        if (user.rating < 0) return false;
        return true;
    }

The type struct<operation> is the result type of Rell operation invocation expression:

    val op: struct<add_user> = add_user('Bob', 123);

the returned value can be used to construct blocks and transactions (in unit tests or REPL):

    val tx = rell.gtx.tx(op);
    tx.run();

Details:

- Attributes of struct<OP> are not mutable.
- Attributes of struct<OP> have same default values as the parameters of OP.
- Member function struct<OP>.to_operation() converts the structure to the "operation" type.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
13. Language: Type struct<mutable T>

In addition to type struct<T> (where "T" is an entity, object or operation), there is type struct<mutable T>:

- struct<T>: all attributes are not mutable
- struct<mutable T>: has same attributes as struct<T>, but all attributes are mutable

To obtain a struct<mutable T> from an entity or an object, use member function .to_mutable_struct():

    val u = user @ { .name == 'Bob' };
    val s = u.to_mutable_struct();              // returns struct<mutable user>

Conversion between struct<T> and struct<mutable T> is done via .to_mutable() and .to_immutable() member functions:

    val s = u.to_struct();
    val mut = s.to_mutable();
    val imm = mut.to_immutable();

The functions create a mutable or immutable copy of a structure.
