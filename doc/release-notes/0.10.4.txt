RELEASE NOTES 0.10.4 (202?-??-??)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
1. Tools: Unit tests

To write unit tests for Rell code, use test modules. A test module is defined using the @test annotation:

    @test module;

    function test_foo() {
        require( 2 + 2 == 4 );
    }
    function test_bar() {
        require( 2 + 2 == 5 );
    }

All functions in a test module that start with "test_" (and a function called exactly "test") are test functions and
will be executed when the test module is run.

To run a test module, use the command-line interpreter:

rell.sh -d my_src_directory my_test_module

Each test function will be executed independently of others, and a summary will be printed in the end:

    ------------------------------------------------------------------------
    TEST RESULTS:

    my_test_module:test_foo OK
    my_test_module:test_bar FAILED

    SUMMARY: 1 FAILED 1 PASSED 2 TOTAL


    ***** FAILED *****

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Tools: Executing transactions and blocks in unit tests

Blocks and transactions created via functions rell.gtx.block() and rell.gtx.tx() can be executed in unit tests
in order to invoke operations and modify data.

Example. Production module, file data.rell:

    module;
    entity user {
        name;
    }
    operation add_user(name) {
        create user(name);
    }

Test module, file data_test.rell:

    @test module;
    import data;

    function test_add_user() {
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        val tx = rell.gtx.tx(data.add_user('Bob'));
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        tx.run();
        require( data.user@*{}(.name) == ['Bob'], 'expected_user_bob' );
    }

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
3. Library: Support for text and byte_array functions in @-expressions

Following functions are now supported in @-expressions (they are translated to their SQL equivalents):

    byte_array.empty()
    byte_array.sub()
    byte_array.to_base64()
    byte_array.to_hex()

    text.char_at()
    text.contains()
    text.empty()
    text.ends_with()
    text.index_of()
    text.replace()
    text.starts_with()
    text.sub()

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Language: Operator [] for text and byte_array types in @-expressions

Subscript operator used to work only in interpreted expressions, now it works in SQL expressions as well.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
5. Library: Function text.like()

New function for simple pattern matching which works same way in interpreted expressions and in @-expressions:

    text.like(pattern): boolean

is equivalent to the SQL LIKE clause:

    <text> LIKE <pattern>

Special character "_" matches any single character and "%" matches any string of zero or more characters.

    print(name.like('% von %'))
    user @* { .name.like('% von %') }

To match characters "_" and "%", escape them with "\" (note that "\\_" in a string literal produces "\_" at run-time,
since "\" is also an escape character in string literals):

    title.like('string\\_with\\_underscores')

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
6. Language: Inference of collection types from return types, variables, attributes, parameters, etc.

It is no more necessary to specify the type of an empty collection when assigning it to a known variable or returning
from a function with a known return type:

    function f(q: integer): list<map<integer,text>> {
        if (q < 0) return [];   // In the past one had to write full type specification: list<map<integer,text>>().
        // ...
    }

Works for lists, sets and maps, for both literals (e. g. [], [:]) and constructors (list(), set(), map()):

    var x: set<text>;
    x = set();

    var m: map<integer, text>;
    m = [:];

"[:]" is a new empty map literal notation, equivalent to expression "map()":

    val m: map<integer, text> = [:];

Some places where collection type inference helps to shorten the code:

- function arguments:                   f([]);
- function parameter default values:    function f(x: list<integer> = []){}
- struct constructor invocation:        my_struct(x = []);
- struct attribute assignment:          struct_object.x = [];
- list/map element assignment:          map_of_lists[x] = [];

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
7. Language: Continue statement

Rell now has the continue statement, like many other languages. It can be used in for and while loops.

for (x in get_list_of_values()) {
    if (x < 0) continue;
    // Do something.
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
8. Language: Offset clause in at-expression

In addition to a limit, one can now also specify an offset in an at-expression in order to select a portion of a
result set:

    user @* {} offset X limit Y

The offset is zero-based, so if offset 0 is specified, all records will be returned, while offset 1 will skip the first
record and so on.

Both limit and offset clauses are optional and can be used together in an arbitrary order.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
9. Language: At-expression for collections

At-expressions can be used to filter and transform collections:

    val l = [1, 2, 3, 4, 5, 6, 7];
    val x = l @* { $ > 4 };
    val y = l @* {} ( $ * $ );

Special symbol "$" is used to access the current item in where- and what-parts. A custom alias can be specified instead:

    val z = (a : l) @* { a > 4 };

Transforming a map:

    val m = ['France':33, 'Italy':39, 'Germany':49];
    val keys = m @* {} ( $.k );
    val values = m @* {} ( $.v );

At-expressions can be chained:

    val q = l
        @* { $ >= 2 }
        @* {} ( $ * $ )
        @* { $ <= 25 }
        ;

Operations are performed in memory, not in database. If applying "at" to a list of entities, each entity will be
selected from the database individually in order to access its attributes (may be slow):

    val all_users = user @* {};                     // Select all users with one SQL query.
    val good_users = all_users @* { $.is_good };    // Slow: will execute SQL query for every user to read its "is_good".

Details:

- All kinds of at-operators are supported: "@", "@?", "@*", "@+".
- Source collection can be a list, a set or a map; the result is always a list (or a single value).
- Where- and what-expressions are not restricted to SQL-compatible ones (e. g. user-defined function calls are allowed).
- Limit and offset clauses are supported.
- Annotations @sort, @sort_desc and @omit are supported.
- Grouping and aggregation is supported (via annotations @group, @sum, @min, @max).
