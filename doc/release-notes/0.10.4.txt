RELEASE NOTES 0.10.4 (202?-??-??)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
1. Tools: Unit tests

To write unit tests for Rell code, use test modules. A test module is defined using the @test annotation:

    @test module;

    function test_foo() {
        require( 2 + 2 == 4 );
    }
    function test_bar() {
        require( 2 + 2 == 5 );
    }

All functions in a test module that start with "test_" (and a function called exactly "test") are test functions and
will be executed when the test module is run.

To run a test module, use the command-line interpreter:

rell.sh -d my_src_directory my_test_module

Each test function will be executed independently of others, and a summary will be printed in the end:

    ------------------------------------------------------------------------
    TEST RESULTS:

    my_test_module:test_foo OK
    my_test_module:test_bar FAILED

    SUMMARY: 1 FAILED 1 PASSED 2 TOTAL


    ***** FAILED *****

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Tools: Executing transactions and blocks in unit tests

Blocks and transactions created via functions rell.gtx.block() and rell.gtx.tx() can be executed in unit tests
in order to invoke operations and modify data.

Example. Production module, file data.rell:

    module;
    entity user {
        name;
    }
    operation add_user(name) {
        create user(name);
    }

Test module, file data_test.rell:

    @test module;
    import data;

    function test_add_user() {
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        val tx = rell.gtx.tx(data.add_user('Bob'));
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        tx.run();
        require( data.user@*{}(.name) == ['Bob'], 'expected_user_bob' );
    }
