RELEASE NOTES 0.10.4 (202?-??-??)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
1. Tools: Unit tests

To write unit tests for Rell code, use test modules. A test module is defined using the @test annotation:

    @test module;

    function test_foo() {
        require( 2 + 2 == 4 );
    }

    function test_bar() {
        require( 2 + 2 == 5 );
    }

All functions in a test module that start with "test_" (and a function called exactly "test") are test functions and
will be executed when the test module is run.

To run a test module, use the command-line interpreter:

rell.sh -d my_src_directory my_test_module

Each test function will be executed independently of others, and a summary will be printed in the end:

    ------------------------------------------------------------------------
    TEST RESULTS:

    my_test_module:test_foo OK
    my_test_module:test_bar FAILED

    SUMMARY: 1 FAILED 1 PASSED 2 TOTAL


    ***** FAILED *****

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Tools: Executing transactions and blocks in unit tests

Blocks and transactions created via functions rell.gtx.block() and rell.gtx.tx() can be executed in unit tests
in order to invoke operations and modify data.

Example. Production module, file data.rell:

    module;

    entity user {
        name;
    }

    operation add_user(name) {
        create user(name);
    }

Test module, file data_test.rell:

    @test module;
    import data;

    function test_add_user() {
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        val tx = rell.gtx.tx(data.add_user('Bob'));
        require( data.user@*{}(.name) == list<text>(), 'expected_no_users' );

        tx.run();
        require( data.user@*{}(.name) == ['Bob'], 'expected_user_bob' );
    }

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
3. Library: Support for text and byte_array functions in @-expressions

Following functions are now supported in @-expressions (they are translated to their SQL equivalents):

    byte_array.empty()
    byte_array.sub()
    byte_array.to_base64()
    byte_array.to_hex()

    text.char_at()
    text.contains()
    text.empty()
    text.ends_with()
    text.index_of()
    text.replace()
    text.starts_with()
    text.sub()

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Language: Operator [] for text and byte_array types in @-expressions

Subscript operator used to work only in interpreted expressions, now it works in SQL expressions as well.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
5. Library: Function text.like()

New function for simple pattern matching which works same way in interpreted expressions and in @-expressions:

    text.like(pattern): boolean

is equivalent to the SQL LIKE clause:

    <text> LIKE <pattern>

Special character "_" matches any single character and "%" matches any string of zero or more characters.

    print(name.like('% von %'))
    user @* { .name.like('% von %') }

To match characters "_" and "%", escape them with "\" (note that "\\_" in a string literal produces "\_" at run-time,
since "\" is also an escape character in string literals):

    title.like('string\\_with\\_underscores')

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
6. Language: Inference of collection types from return types, variables, attributes, parameters, etc.

It is no more necessary to specify the type of an empty collection when assigning it to a known variable or returning
from a function with a known return type:

    function f(q: integer): list<map<integer,text>> {
        if (q < 0) return [];   // In the past one had to write full type specification: list<map<integer,text>>().
        // ...
    }

Works for lists, sets and maps, for both literals (e. g. [], [:]) and constructors (list(), set(), map()):

    var x: set<text>;
    x = set();

    var m: map<integer, text>;
    m = [:];

"[:]" is a new empty map literal notation, equivalent to expression "map()":

    val m: map<integer, text> = [:];

Some places where collection type inference helps to shorten the code:

- function arguments:                   f([]);
- function parameter default values:    function f(x: list<integer> = []){}
- struct constructor invocation:        my_struct(x = []);
- struct attribute assignment:          struct_object.x = [];
- list/map element assignment:          map_of_lists[x] = [];

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
7. Language: Continue statement

Rell now has the continue statement, like many other languages. It can be used in for and while loops.

for (x in get_list_of_values()) {
    if (x < 0) continue;
    // Do something.
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
8. Language: Offset clause in at-expression

In addition to a limit, one can now also specify an offset in an at-expression in order to select a portion of a
result set:

    user @* {} offset X limit Y

The offset is zero-based, so if offset 0 is specified, all records will be returned, while offset 1 will skip the first
record and so on.

Both limit and offset clauses are optional and can be used together in an arbitrary order.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
9. Language: At-expression for collections

At-expressions can be used to filter and transform collections:

    val l = [1, 2, 3, 4, 5, 6, 7];
    val x = l @* { $ > 4 };
    val y = l @* {} ( $ * $ );

Special symbol "$" is used to access the current item in where- and what-parts. A custom alias can be specified instead:

    val z = (a : l) @* { a > 4 };

Transforming a map:

    val m = ['France':33, 'Italy':39, 'Germany':49];
    val keys = m @* {} ( $.k );
    val values = m @* {} ( $.v );

At-expressions can be chained:

    val q = l
        @* { $ >= 2 }
        @* {} ( $ * $ )
        @* { $ <= 25 }
        ;

Operations are performed in memory, not in database. If applying "at" to a list of entities, each entity will be
selected from the database individually in order to access its attributes (may be slow):

    val all_users = user @* {};                     // Select all users with one SQL query.
    val good_users = all_users @* { $.is_good };    // Slow: will execute SQL query for every user to read its "is_good".

Details:

- All kinds of at-operators are supported: "@", "@?", "@*", "@+".
- Source collection can be a list, a set or a map; the result is always a list (or a single value).
- Where- and what-expressions are not restricted to SQL-compatible ones (e. g. user-defined function calls are allowed).
- Limit and offset clauses are supported.
- Annotations @sort, @sort_desc and @omit are supported.
- Grouping and aggregation is supported (via annotations @group, @sum, @min, @max).

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
10. Language: Key and index attribute syntax improvements

Now one can specify mutability and default value for particular attributes within a key or index clause:

    entity address {
        index mutable city: text = 'London', mutable street: text = 'Unknown';
    }

In previous versions that code would like like this:

    entity address {
        mutable city: text = 'London';
        mutable street: text = 'Unknown';
        index city, street;
    }

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
11. Language: Types struct<entity> and struct<object>

A new type allows to have a struct which has same attributes as an entity or an object:

    entity user {
        name;
        address: text;
    }

    operation add_user(data: struct<user>) {
        //...
    }

An instance of a struct<T> can be created same way as for a regular struct:

    val s = struct<user>(name = 'Bob', address = '33 Main St.');

It's also possible to obtain a struct-copy of an entity/object using the 'to_struct()' function:

    val u = user @ { .name == 'Bob' };
    val s = u.to_struct();              // returns struct<user>

Alternatively, 'to_struct()' can be used in an at-expression (in the what-part):

    val s = user @ { .name == 'Bob' } ( user.to_struct() );

One can pass a struct<entity> to a create expression instead of specifying individual attributes of the entity:

    create user(s);       // s is struct<user>

Details:

- Attributes of struct<T> are not mutable regardless of the mutability of the attributes of the underlying type.
- Attributes of struct<T> have same default values as the attributes of T.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
12. Language: Type struct<operation>

A new type struct<operation> defines a struct which has same attributes as the operation's parameters:

    operation add_user(name: text, rating: integer) {
        //...
    }

    query can_add_user(user: struct<add_user>) {
        if (user.name == '') return false;
        if (user.rating < 0) return false;
        return true;
    }

The type struct<operation> is the result type of Rell operation invocation expression:

    val op: struct<add_user> = add_user('Bob', 123);

the returned value can be used to construct blocks and transactions (in unit tests or REPL):

    val tx = rell.gtx.tx(op);
    tx.run();

Details:

- Attributes of struct<OP> are not mutable.
- Attributes of struct<OP> have same default values as the parameters of OP.
- Member function struct<OP>.to_operation() converts the structure to the "operation" type.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
13. Language: Type struct<mutable T>

In addition to type struct<T> (where "T" is an entity, object or operation), there is type struct<mutable T>:

- struct<T>: all attributes are not mutable
- struct<mutable T>: has same attributes as struct<T>, but all attributes are mutable

To obtain a struct<mutable T> from an entity or an object, use member function .to_mutable_struct():

    val u = user @ { .name == 'Bob' };
    val s = u.to_mutable_struct();              // returns struct<mutable user>

Conversion between struct<T> and struct<mutable T> is done via .to_mutable() and .to_immutable() member functions:

    val s = u.to_struct();
    val mut = s.to_mutable();
    val imm = mut.to_immutable();

The functions create a mutable or immutable copy of a structure.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
14. Language: Nested at-expressions under exists() and empty() functions

Nested at-expressions passed as an argument to functions exists() and empty() can access entities of an outer
at-expression:

    user @* {
        exists( company @* { .city == user.city } )
    }

This allows to execute database queries which used to be impossible in earlier versions of Rell. Only independent
nested at-expressions were supported, and they were translated and executed as independent SQL queries.

Now the whole at-expression is translated to a single SQL query, which may look like this:

    SELECT U."name" FROM "c0.user" U WHERE EXISTS( SELECT C."rowid" FROM "c0.company" C WHERE C."city" = U."city" )

Same functionality can be used within "update" and "delete" statements as well:

    delete user @* { not exists( company @* { .city == user.city } ) } ;

* Note on cardinality *

A nested at-expression shall use operator "@*", because it is not possible to check the number of records selected with
a nested SQL query. However, operators "@+", "@?" or "@" are still allowed, but using them causes a nested expression
to be executed independently, not as an SQL sub-query. Thus, outer entities cannot be accessed, and the code may become
considerably slower (the nested expression will load the entire result set into memory to execute exists(), as there is
no optimization of that special case yet).

* Attributes matching in where-part *

Expressions like ".attribute == outer_entity.attribute" can be shortened to just "outer_entity.attribute" in the
where-part of a nested expression:

    user @* {
        exists( company @* { user.city } )
    }

An attribute of a nested entity is matched by the name and type of the outer attribute.

* More details *

- Function "empty(X)" is equivalent to "not exists(X)" and is translated to "NOT EXISTS()" SQL expression.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15. Language: Nested at-expressions for the "in" operator

Similarly to the exists() and empty() functions, operator "in" now supports nested at-expressions:

    user @* {
        .city in company @* {} ( company.city )
    }

Such nested expressions can access entities of a parent at-expression and are translated to nested SELECT queries
when executed. For example, the expression

    user @* {
        .city in company @* { user.industry } ( company.city )
    }

is translated to an SQL query like:

    SELECT U."rowid" FROM "c0.user" U
    WHERE U."city" IN (SELECT C."city" FROM "c0.company" C WHERE C."industry" = U."industry")

Same notes regarding cardinality and attributes matching as for empty() and exists() apply.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
16. Language: Operator "in" for collections supports database expressions

Example:

    user @* { .city in ['London', 'Paris', 'Berlin'] }

The right-hand side operand can be an arbitrary list or set expression, not necessarily a constant one:

    user @* { .city in get_list_of_cities() }

Entity attributes can be used in a list literal as well:

    user @* { 'London' in [.home_city, .work_city] }

Note. The number of values that can be used in a single database query is limited, the current limit is 32767. If a
collection passed to operator "in" contains more elements than that, the at-expression will fail at run-time.
(The limit is for the total number of values in one at-expression, not for each individual "in" operator.)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
17. Language: Binary operator "not in"

One can now write:

    X not in Y

instead of

    not (X in Y)

The new notation is supposed to be more readable when X and Y are complex expressions.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
18. Tools: Specifying source code compatibility version in blockchain configuration

In blockchain XML configuration (so-called blockchain.xml format), old key "sources_v0.10" is replaced by a pair of
new keys: "sources" and "version". Those keys are under the same path, in the "rell" node:

        <entry key="rell">
            <dict>
                <entry key="sources">
                    <dict>
                        <entry key="user.rell">...</entry>
                    </dict>
                </entry>
                <entry key="version">
                    <string>0.10.4</string>
                </entry>
            </dict>
        </entry>

The "version" key is mandatory. Its main purpose is to provide backwards compatibility of future versions of Rell in
case if there are breaking changes. Thus, Rell module written for an older version of Rell will work with a newer version
of Rell interpreter. Currently, there are no breaking changes, but there can be some in the future.

If an older version number is specified, the code can still use features of newer versions of Rell (assuming a newer
version of Rell interpreter is used).

More details:

- The old key "sources_v0.10" is still supported, but will not be in newer versions of Rell.
- Command-line tools, like multigen.sh, have an optional parameter for specifying the version: "--source-version".
- In Rell 0.10.4 the specified version has no effect, but it must be a valid Rell version.
