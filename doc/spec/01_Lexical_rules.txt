1. Lexical Rules


1.1. Whitespaces, comments

(1) Whitespaces are like in Java: characters for which java.lang.Character.isWhitespace(c) == true (e. g. space, tab, end-of-line, etc.).

(2) Comments are like in Java.

(2.1) Single-line comment: starts with "//", ends with end-of-line or end-of-file.

(2.2) Multiline comment: starts with "/*", ends with "*/".

(2.3) Error if there is no "*/" after "/*".


1.3. Identifiers:

(1) Identifiers are like in Java: first character has java.lang.Character.isJavaIdentifierStart(c) == true, other characters have java.lang.Character.isJavaIdentifierPart(c) == true.

Simple definition: sequence of letters, digits and underscores ("_"), first character is not a digit. Can contain non-English letters.

(2) Identifiers are case-sensitive.


1.4. Keywords:

(1) Keyword is one of the following reserved identifiers:

and
break
class
create
delete
else
false
for
function
if
in
index
key
limit
list
map
mutable
not
null
operation
or
query
return
set
sort
true
update
val
var
while

(2) A keyword cannot be used as a general identifier, i. e. as a name of a class, function, variable, etc.

(3) Longest possible keyword/identifier is taken, i. e. string "format" is an identifier "format", not keyword "for" and identifier "mat".


1.5. Operators, delimiters:

(1) List of operators and delimiters:

!!
!=
%
%=
(
)
*
*=
+
+=
,
-
-=
.
/
/=
:
;
<
<=
=
==
>
>=
?
?.
?:
@
[
]
{
}

(2) Longest possible operator/delimiter is taken, i. e. string "<=" is a single operator "<=", not two operators "<" and "=".


1.6. Integer literals:

(1) Decimal: regex /[0-9]+/.

(1.1) Maximum decimal value: 9223372036854775807 (2^63 - 1). Error if the value is greater.

(2) Hex: regex /0x[0-9A-Fa-f]+/, e. g. 0x0, 0xABCD, etc.

(2.1) Maximum hex value: 0x7FFFFFFFFFFFFFFF (2^63 - 1). Error if the value is greater.

(3) Cannot have a letter directly after an integer literal, e. g. "1234X" is an error, not two tokens "1234", "X".


1.7. String literals:

(1) Enclosed in single (') or double (") quotes.

(2) There is no difference between single-quoted and double-quoted strings, i. e. 'Hello' and "Hello" are equal string literals.

(3) Cannot contain an end-of-line character (0x0A), i. e. closing quote must be on the same line as the open quote.

(4) Error if there is no closing quote on the same line.

(5) Escape sequences

(5.1) Simple escape sequences:

\b
\t
\r
\n
\"
\'
\\

(5.2) Unicode escape sequence: \u1234, \uABCD, \uAbCd, etc. - must have exactly 4 hex digits.

(5.3) Error if wrong escape sequence is specified ("\" character, but not one of valid escape sequences).


1.8. Byte array literals:

(1) Syntax: x"..." or x'...', only hex digits (upper or lower case) can be used within quotes.

Examples:
x''
x"123456"
x"DeadBeef"

(2) Must start with lower-case "x", not upper-case "X".

(3) Must contain an even (2*N) number of hex digits (because 1 byte = 2 hex digits).

(4) Cannot contain escape sequences or end-of-lines.
