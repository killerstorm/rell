4. Operations, Queries, Functions

Let's say that operations, queries and functions are routines. Some rules are common for all routines, while other rules are specific for operations, queries or functions.


(1) Syntax:

Module : Definition*

Definition : ClassDefinition | RoutineDefinition

RoutineDefinition : Operation | Query | Function

(1.1) ClassDefinition syntax is given in chapter 3.

(2) Each ruotine has a name.

(2.1) Error when defining a routine, and another routine with the same name already exists.

Built-in functions are also taken into account when checking this rule. (The list of built-in functions will be given in a future chapter.)


4.1. Operations

(1) Syntax:

Operation : "operation" Identifier "(" FormalParams? ")" BlockStatement

FormalParams : FieldDefinition ( "," FieldDefinition )*

BlockStatement : "{" Statement* "}"

(1.1) FieldDefinition syntax is given in chapter 3 (it's the same as for class fields).

(1.2) Statement syntax will be given in a future chapter about statements.

(2) Return type of an operation is "unit".

(2.1) Thus, an operation cannot return a value. Return statement cannot have an expression, even if the expression returns unit:

return; // OK

return print('Hello'); // Error, even though print() returns unit.

(3) Examples

operation foo(user; value: integer) {
    if (value == 0) return;
    update account @ { user } ( score += value );
}


4.2. Queries

(1) Syntax:

Query : "query" Identifier "(" FormalParams? ")" (":" Type)? QueryBody

QueryBody : SimpleBody | ComplexBody

SimpleBody : "=" Expression ";"

ComplexBody : BlockStatement

(2) Return type

(2.1) A query has a specific return type and always returns a value.

(2.2) If return type is not specified explicitly, it is implicitly deducted from return expressions.

(2.2.1) For simple body: return type is the type of the expression.

(2.2.1.1) Error if the type of the expression is "unit".

(2.2.2) For complex body: return type is the common type of types of all expressions used in return statements.

(2.2.2.1) Error if there is no common type for return expressions types.

(2.3) If explicit return type is specified.

(2.3.1) For simple body: error if the type of the expression is not a subtype of the explicit return type.

(2.3.2) For complex body: error if the type of the expression in a return statement is not a subtype of the explicit return type.

(2.4) For complex body: error if there is no return statement.

(3) Examples

query getUserCount(company) = (user @* { company }).size(); // Returns integer.

query getUserCount(companyName) {
    if (companyName == "") return 0;
    return (user @* { company.name == companyName }).size();
}

Error: no common return type
query q(x: integer) {
    if (x < 0) return 'Hello';
    return 123;    // Error on this line.
}

Error: actual return type differs from the declared one
query q(): integer = 'Hello';
query q(): integer { return 'Hello'; }


4.3. Functions

(1) Syntax:

Function : "function" Identifier "(" FormalParams? ")" (":" Type)? FunctionBody

FunctionBody : SimpleBody | ComplexBody

(2) Return type

(2.1) If return type is not specified, the return type of the function is "unit".

(2.2) Simple body: the type of the expression must be a subtype of the return type of the function.

(2.2.1) The type of the expression cannot be "unit".

(2.3) Complex body

(2.3.1) If return type is not specified (thus, it is "unit"), return statements must have no expression (i. e. must use "return;", not "return X;").

(2.3.2) If return type is specified, type of expressions in return statements must be a subtype of the return type.

(3) Order of function definitions does not matter, all functions defined in a module are visible everywhere in the module.

This allows recursive and mutually-recursive functions:

function a(x: integer) {
    if (x > 0) b(x - 1); // b() is visible here, but it is defined below.
}

function b(x: integer) {
    if (x > 0) a(x - 1);
}


4.4. Common things for routines

(1) Queries and non-unit functions must always return a value.

(1.1) Error if there is no return statement on one of code paths:

function f(x: integer): integer {
    print(x);
} // Error: no return statement at all.

function f(x: integer): integer {
    if (x > 0) return x * x;
} // Error: no return statement for one of code paths.

function f(x: integer): integer {
    if (x > 0) {
        return x * x;
    } else {
        print('invalid argument');
    } // Error: no return statement for this branch.
}

(1.2) More formal rules how to check if there is a return value will be given in the chapter on statements (future).
