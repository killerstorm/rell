2. Types


2.1. General

(1) A type of an attribute, parameter, variable, etc. can be:

- name of a built-in or user-defined type (Identifier)
- nullable type
- tuple type
- collection type

(2) Built-in types

(2.1) Basic built-in types are:

boolean
byte_array
integer
json
range
text

(2.2) Built-in type aliases are:

name = text
pubkey = byte_array
timestamp = integer
tuid = text

(3) Type alias A = T means that entities (attributes, variables, etc.) of type A will effectively have type T during compilation.


2.2. Special types

Special types cannot be used in code explicitly (in attribute declarations, etc.), but they are used by the compiler internally as types of some expressions.

(1) Special types are: unit, null.

(2) Names of special types cannot be used in code as types. Trying to use "unit" as a type causes an error e. g. "Unknown type name". "null" is a keyword, so using it as a type is a syntax error.


2.3. Nullable type

The idea was taken from Kotlin.

(1) Syntax:

NullableType: Type "?"

Examples:
integer?
list<text>?

(2) Error if the underlying type is nullable, e. g. integer??.


2.4. Tuple type

Consists of one or more fields. Each field must have a type and may have a name.

(1) Syntax:

TupleType: "(" TupleTypeField ( "," TupleTypeField )* ")"

TupleTypeField: ( Identifier ":" )? Type

Examples:
(integer)
(integer, text)
(x: integer, y: integer)
(p: text, q: byte_array, list<integer>)

(2) Error if same field name is used more than once.


2.5. Collection types

Collection types are: list, set, map.

(1) Syntax:

"list" "<" Type ">"
"set" "<" Type ">"
"map" "<" Type "," Type ">"

Examples:
list<integer>
set<text>
map<text, byte_array>


2.6. Subtypes

Purpose: if type B is a subtype of type A, a value of type B can be assigned to a variable of type A.

(1) T is subtype of T.

(2) T is subtype of T?.

(3) null is subtype of T?.

(4) Tuple type T1 is subtype of tuple type T2 if:

- the number of fields is the same
- names of corresponding fields are the same (if a field has no name, the other field must have no name)
- type of each field of T1 is a subtype of the type of the corresponding field of T2

Examples:

(integer, text) is subtype of (integer, text?)
(integer, text?) is subtype of (integer?, text?)
(integer, text?) is not subtype of (integer, text), because text? is not subtype of text

(x: integer, y: integer) is subtype of (x: integer?, y: integer?)
(x: integer, y: integer) is not subtype of (p: integer, q: integer), because field names differ
(integer, text) is not subtype of (x: integer, y: integer)
(x: integer, y: integer) is not subtype of (integer, text)


2.7. Common type

(1) A common type of two types T1 and T2 is a type T such that T1 and T2 are subtypes of T.

Common type is used, for instance, to determine an implicit return type of a query if there are multiple return statements with different types.

(2) Calculating common type:

(2.1) Commutativity: common_type(T1, T2) == common_type(T2, T1).

(2.2) If T1 is subtype of T2, the common type is T2. Check for (T1, T2), then for (T2, T1).

(2.3) If T1 is null and T2 is not nullable, the common type is T2? (nullable T2). Check for (T1, T2), then for (T2, T1).

(2.4) If T1 and T2 are tuples, but neither is a subtype of the other:

- If number of fields and field names are the same.
- And if types of all pairs of corresponding fields of T1 and T2 have a common type.
- Then the common type of T1 and T2 is a tuple where the type of each field is the common type of the corresponding fields of T1 and T2.

(2.5) In all other cases types T1 and T2 have no common type.

(3) Common type of multiple types T1, T2, ..., Tn is:

(3.1) common_type(T1, T2, T3) = common_type(common_type(T1, T2), T3)

(3.2) common_type(T1, T2, ..., Tn) = common_type(common_type(T1, T2, ..., Tn-1), Tn)
