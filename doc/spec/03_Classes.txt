3. Classes


3.1. Class has a name and zero or more member definitions.

(1) When a class with name A is defined, A can be used as a type name in the code after the class definition.

(2) Error if there already is a built-in or user-defined type with same name.

(3) Class members are: attribute, key, index.


3.2. Class syntax:

ClassDefinition : "class" Identifier "{" ClassMemberDefinition* "}"

ClassMemberDefinition :
    AttributeDefinition
    KeyDefinition
    IndexDefinition

Example:

class user {
    name: text;
    address: text;
    key name;
    index address;
}


3.3. Attributes

Attribute definition may contain a name, type, default value expression and modifiers (e. g. mutable).

(1) Syntax:

AttributeDefinition: "mutable"? FieldDefinition ("=" Expression) ";"

FieldDefinition: Identifier (":" Type)?

(2) If type is not specified, same type as the attribute name is taken (built-in or user-defined). Error if there is no such type.

(2.1) Following types cannot be used for class attributes:

nullable type
tuple type
range
list<T>
set<T>
map<K,V>

(3) Error if there already is another attribute with same name in the same class.

(4) If default value expression is specified, the type of the expression must be a subtype of the attribute's type.

Expressions specification will be written later. We can use simplest expressions now for testing: integer literal, string literal, true, false, null, etc.

(5) Examples:

name;            // same as "name: name;", there is a built-in type "name"
address: text;
mutable age: integer;
mutable status: text = 'Unknown';

3.4. Keys, indices

Keys and indices consist of one or more fields.

(1) Syntax:

KeyDefinition: "key" FieldDefinition ("," FieldDefinition)* ";"

IndexDefinition: "index" FieldDefinition ("," FieldDefinition)* ";"

(2) Handling of fields:

(2.1) Error if same field name is used more than once within one key/index.

(2.2) If there is no attribute with such name, an attribute is added to the class implicitly. The added attribute is not mutable, has no default value.

(2.3) If there is an attribute with such name, the key/index field cannot have a type specified.

No error:
key foo: integer;

Error:
foo: integer;
key foo: integer;

(3) Error if there already is a key/index with same set of fields.

Not an error:
index a;
index a, b;

Error:
index a, b;
index b, a;

(4) It does not matter if a key/index is defined before or after an attribute used in it.

Code:
x: integer;
key x;

is equivalent to:
key x;
x: integer;

(4.1) Same for field type restrictions: does not matter whether a key/index is defined before or after the attribute.

No error:
key x: integer;

No error:
x: integer;
key x;

Error:
x: integer;
key x: integer; // ERROR

Error:
key x: integer; // ERROR
x: integer;
